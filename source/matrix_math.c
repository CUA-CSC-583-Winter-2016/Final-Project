#include "matrix_math.h"

void eye_proj_mat(float left, float right, float top, float bottom, float far, const float *eye, float *mat) {
  // I believe this'll only work if everything is behind the xy plane in the -z direction.
  // This is basically an implementation of the multiplication of a matrix generated by glFrustrum and a translation matrix. See https://www.opengl.org/sdk/docs/man2/xhtml/glFrustum.xml
  // Everything is translated to camera space first, then the perspective transform is applied.
  // Link to math: https://www.wolframalpha.com/input/?i=[[%282*n%29%2F%28r-l%29,0,%28r%2Bl%29%2F%28r-l%29,0],[0,%282*n%29%2F%28t-b%29,%28t%2Bb%29%2F%28t-b%29,0],[0,0,-%28f%2Bn%29%2F%28f-n%29,-%282*f*n%29%2F%28f-n%29],[0,0,-1,0]]*[[1,0,0,X],[0,1,0,Y],[0,0,1,Z],[0,0,0,1]]

  // Translate the display bounds to eye space.
  right -= eye[0];
  left -= eye[0];
  top -= eye[1];
  bottom -= eye[1];
  far += eye[2]; // Near and far value are positive despite the planes being in the negative z axis.
  float near = eye[2];

  // row major
  // frustrum * translate
  // I haven't tested this crazy thing yet.
  mat[0] = 2*near/(right-left);
  mat[1] = 0.0;
  mat[2] = (right+left)/(right-left);
  mat[3] = (-2*near*eye[0]-(left+right)*eye[2])/(right-left);

  mat[4] = 0.0;
  mat[5] = 2*near/(top-bottom);
  mat[6] =(bottom+top)/(top-bottom);
  mat[7] =(-2*near*eye[1]-(bottom+top)*eye[2])/(top-bottom);

  mat[8] = 0.0;
  mat[9] = 0.0;
  mat[10] = (-far-near)/(far-near);
  mat[11] = ((far+near)*eye[2]-2*far*near)/(far-near);

  mat[12] = 0.0;
  mat[13] = 0.0;
  mat[14] = -1.0;
  mat[15] = eye[2];

}


void unproject_kinect_depth(int xin, int yin, uint16_t zin, float *xout, float *yout, float *zout) {
  // See these pages for info on the kinect depth data
  // https://openkinect.org/wiki/Imaging_Information#Depth_Camera
  // https://msdn.microsoft.com/en-us/library/hh973078.aspx
  // TODO implement
  *xout = xin;
  *yout = yin;
  *zout = zin;
}
